{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SVETlANNa","text":"<p>Welcome to the SVETlANNa package documentation.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install svetlanna\n</code></pre>"},{"location":"#about","title":"About","text":""},{"location":"reference/linear_optical_setup/","title":"LinearOpticalSetup","text":""},{"location":"reference/linear_optical_setup/#svetlanna.LinearOpticalSetup","title":"svetlanna.LinearOpticalSetup","text":"<pre><code>LinearOpticalSetup(elements: Iterable[Element])\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Linear optical network composed of <code>Element</code> instances. It works the same way as a <code>torch.nn.Sequential</code> module, but with some additional features.</p> <p>Parameters:</p> <ul> <li> <code>elements</code>               (<code>Iterable[Element]</code>)           \u2013            <p>Optical elements that make up the setup. Elements are evaluated in the provided order.</p> </li> </ul> <p>Examples:</p> <pre><code>import svetlanna as sv\n\nsetup = sv.LinearOpticalSetup(\n    elements=[\n        element1,\n        element2,\n        element3,\n    ]\n)\n\noutput_wavefront = setup(input_wavefront)\n</code></pre>"},{"location":"reference/linear_optical_setup/#svetlanna.LinearOpticalSetup.reverse","title":"reverse","text":"<pre><code>reverse(Ein: Tensor) -&gt; Tensor\n</code></pre> <p>Reverse propagation through the setup. All elements in the setup must have a <code>reverse</code> method. If any element lacks this method, a <code>TypeError</code> is raised.</p> <p>Parameters:</p> <ul> <li> <code>Ein</code>               (<code>Tensor</code>)           \u2013            <p>Input wavefront to reverse propagate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Output wavefront after reverse propagation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If reverse propagation is not supported by all elements in the setup.</p> </li> </ul>"},{"location":"reference/logging/","title":"Logging","text":""},{"location":"reference/logging/#svetlanna.logging.set_debug_logging","title":"svetlanna.logging.set_debug_logging","text":"<pre><code>set_debug_logging(\n    mode: bool, type: Literal[\"logging\", \"print\"] = \"print\"\n)\n</code></pre> <p>Enable or disable debug logging for elements.</p> <p>Logs information about element registration (parameters, buffers, submodules) and forward pass execution. This helps debug and trace data flow through the optical setup.</p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>bool</code>)           \u2013            <p>Whether to enable debug logging.</p> </li> <li> <code>type</code>               (<code>Literal['logging', 'print']</code>, default:                   <code>'print'</code> )           \u2013            <p>Output method: <code>'print'</code> uses <code>print()</code>, <code>'logging'</code> writes to the <code>svetlanna.logging</code> logger at DEBUG level, by default <code>'print'</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>type</code> is not <code>'logging'</code> or <code>'print'</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>import svetlanna as sv\nimport torch\nfrom svetlanna.logging import set_debug_logging\n\nset_debug_logging(True)\n\nsim_params = sv.SimulationParameters(...)\n\ndiffractive_layer = sv.elements.DiffractiveLayer(\n    simulation_parameters=sim_params,\n    mask=torch.rand(Ny, Nx),\n)\ninput_wavefront = sv.Wavefront.plane_wave(sim_params)\ndiffractive_layer(input_wavefront)\n</code></pre> <p>Output: <pre><code>Buffer of DiffractiveLayer was registered with name mask:\n   &lt;class 'torch.Tensor'&gt; shape=torch.Size([512, 512]), dtype=torch.float32, device=cpu\nThe forward method of DiffractiveLayer was computed\n   input 0: &lt;class 'svetlanna.wavefront.Wavefront'&gt; shape=torch.Size([512, 512]), dtype=torch.complex64, device=cpu\n   output 0: &lt;class 'svetlanna.wavefront.Wavefront'&gt; shape=torch.Size([512, 512]), dtype=torch.complex64, device=cpu\n</code></pre></p>"},{"location":"reference/parameters/","title":"Parameter and ConstrainedParameter","text":""},{"location":"reference/parameters/#svetlanna.Parameter","title":"svetlanna.Parameter","text":"<pre><code>Parameter(data: Any, requires_grad: bool = True)\n</code></pre> <p>               Bases: <code>Tensor</code></p> <p><code>torch.Parameter</code>-like tensor with an internal storage module.</p> <p>This class is used to keep a trainable <code>torch.nn.Parameter</code> inside a <code>torch.nn.Module</code> while presenting a <code>torch.Tensor</code>-like interface.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Initial value, should be a tensor or convertible to a tensor.</p> </li> <li> <code>requires_grad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the parameter requires gradients, by default True.</p> </li> </ul> <p>Examples:</p> <p>You can use <code>Parameter</code> as a trainable parameter in any SVETlANNa element when it is typed as OptimizableFloat or OptimizableTensor: <pre><code>import svetlanna as sv\nimport torch\n\nsim_params = sv.SimulationParameters(...)\n\ndiffractive_layer = sv.elements.DiffractiveLayer(\n    simulation_parameters=sim_params,\n    mask=sv.Parameter(2 * torch.pi * torch.rand(Ny, Nx)),\n)\n</code></pre></p>"},{"location":"reference/parameters/#svetlanna.ConstrainedParameter","title":"svetlanna.ConstrainedParameter","text":"<pre><code>ConstrainedParameter(\n    data: Any,\n    min_value: Any,\n    max_value: Any,\n    bound_func: Callable[[Tensor], Tensor] = sigmoid,\n    inv_bound_func: Callable[[Tensor], Tensor] = logit,\n    requires_grad: bool = True,\n)\n</code></pre> <p>               Bases: <code>Parameter</code></p> <p>Parameter constrained to a bounded range.</p> <p>The constraint is implemented by applying <code>bound_func</code> to the inner parameter, mapping it to \\([0, 1]\\), and then scaling and shifting it to <code>(min_value, max_value)</code>.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Initial parameter value.</p> </li> <li> <code>min_value</code>               (<code>Any</code>)           \u2013            <p>Minimum allowed value.</p> </li> <li> <code>max_value</code>               (<code>Any</code>)           \u2013            <p>Maximum allowed value.</p> </li> <li> <code>bound_func</code>               (<code>Callable[[Tensor], Tensor]</code>, default:                   <code>sigmoid</code> )           \u2013            <p>Function that maps \\(\\mathbb{R}\\to[0,1]\\), by default <code>torch.sigmoid</code>.</p> </li> <li> <code>inv_bound_func</code>               (<code>Callable[[Tensor], Tensor]</code>, default:                   <code>logit</code> )           \u2013            <p>Inverse of <code>bound_func</code>, by default <code>torch.logit</code>. It is used once to compute the initial inner parameter value from <code>data</code>.</p> </li> <li> <code>requires_grad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the parameter requires gradients, by default True.</p> </li> </ul> <p>Examples:</p> <p>You can use <code>ConstrainedParameter</code> as a trainable parameter in any SVETlANNa element when it is typed as OptimizableFloat or OptimizableTensor: <pre><code>import svetlanna as sv\nimport torch\n\nsim_params = sv.SimulationParameters(...)\n\ndiffractive_layer = sv.elements.DiffractiveLayer(\n    simulation_parameters=sim_params,\n    mask=sv.ConstrainedParameter(\n        2 * torch.pi * torch.rand(Ny, Nx),\n        min_value=0,\n        max_value=2 * torch.pi,\n    )\n)\n</code></pre></p>"},{"location":"reference/parameters/#svetlanna.ConstrainedParameter.value","title":"value  <code>property</code>","text":"<pre><code>value: Tensor\n</code></pre> <p>Constrained parameter value.</p> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Constrained value computed with <code>bound_func</code>.</p> </li> </ul>"},{"location":"reference/parameters/#svetlanna.parameters.OptimizableFloat","title":"svetlanna.parameters.OptimizableFloat  <code>module-attribute</code>","text":"<pre><code>OptimizableFloat: TypeAlias = (\n    float | Tensor | Parameter | Parameter\n)\n</code></pre> <p>Union type for scalar values that can be optimized. Accepts Python floats, scalar tensors, <code>torch.nn.Parameter</code>, or Parameter instances.</p>"},{"location":"reference/parameters/#svetlanna.parameters.OptimizableTensor","title":"svetlanna.parameters.OptimizableTensor  <code>module-attribute</code>","text":"<pre><code>OptimizableTensor: TypeAlias = (\n    Tensor | Parameter | Parameter\n)\n</code></pre> <p>Union type for tensor values that can be optimized. Accepts tensor values, <code>torch.nn.Parameter</code>, or Parameter instances.</p>"},{"location":"reference/partial_with_parameters/","title":"PartialWithParameters","text":""},{"location":"reference/partial_with_parameters/#svetlanna.PartialWithParameters","title":"svetlanna.PartialWithParameters","text":"<pre><code>PartialWithParameters(\n    function: Callable[\n        Concatenate[_Input, _Params], _Output\n    ],\n    *args: args,\n    **kwargs: kwargs\n)\n</code></pre> <p>               Bases: <code>Module</code>, <code>Generic[_Input, _Output]</code></p> <p>Wrap an arbitrary function with trainable keyword arguments.</p> <p>This behaves like <code>functools.partial</code>, but only keyword arguments are supported. Use this wrapper when you want keyword arguments to be registered as trainable parameters or as buffers (for tensor-valued constants). This is especially useful for multi-device workflows, since parameters and buffers move with the module.</p> <p>Parameters:</p> <ul> <li> <code>function</code>               (<code>Callable[Concatenate[_Input, _Params], _Output]</code>)           \u2013            <p>Arbitrary function with parameters.</p> </li> <li> <code>*args</code>               (<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments (not supported; must be empty).</p> </li> <li> <code>**kwargs</code>               (<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for the function. Values are registered as parameters, buffers, or plain attributes depending on their type.</p> </li> </ul> <p>Examples:</p> <p>Suppose you have a function that describes a nonlinear response and has trainable parameters. See the example in NonlinearElement.</p>"},{"location":"reference/simulation_parameters/","title":"SimulationParameters","text":""},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters","title":"svetlanna.SimulationParameters","text":"<pre><code>SimulationParameters(axes: Mapping[str, Tensor | float])\n</code></pre><pre><code>SimulationParameters(\n    *,\n    x: Tensor | float,\n    y: Tensor | float,\n    wavelength: Tensor | float,\n    **additional_axes: Tensor | float\n)\n</code></pre> <pre><code>SimulationParameters(\n    axes: Mapping[str, Tensor | float] | None = None,\n    /,\n    **kwaxes: Tensor | float,\n)\n</code></pre> <p>Simulation parameters. Manages coordinate systems and physical parameters for optical simulations. Required axes: <code>x</code>, <code>y</code>, <code>wavelength</code>. Additional axes can be added.</p> <p>Examples:</p> <p>Let's define simalation grid of width and height of 1 mm with 512 points for both axes (<code>Nx=Ny=512</code>) and wavelength of 632.8 nm: <pre><code>import svetlanna as sv\nfrom svetlanna.units import ureg\nimport torch\n\nsim_params = sv.SimulationParameters(\n    x=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    y=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    wavelength=632.8 * ureg.nm,\n)\n</code></pre> You can make <code>wavelength</code> an array for polychromatic simulations: <pre><code>sim_params = sv.SimulationParameters(\n    x=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    y=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    wavelength=torch.linspace(600, 800, 10) * ureg.nm,\n)\n</code></pre></p> <p>The order of axes matters! It defines the order of dimensions in wavefront tensors. In first case above, all optical elements will expect wavefront tensors with shape <code>(..., Ny, Nx)</code>, while in the second case, the expected shape will be <code>(..., Nwavelength, Ny, Nx)</code>. <code>...</code> means any number of leading dimensions (e.g., for batch).</p> <p>If you change the order: <pre><code>sim_params = sv.SimulationParameters(\n    x=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    wavelength=torch.linspace(600, 800, 10) * ureg.nm,\n    y=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n)\n</code></pre> the expected order of axes is <code>('y', 'wavelength', 'x')</code>, so all optical elements will expect wavefront tensors with shape <code>(..., Ny, Nwavelength, Nx)</code>.</p> <p>You can add custom axes as needed: <pre><code>sim_params = sv.SimulationParameters(\n    t=torch.linspace(0, 1, 5) * ureg.s,  # time axis\n    x=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n    wavelength=632.8 * ureg.nm,\n    y=torch.linspace(-0.5, 0.5, 512) * ureg.mm,\n)\n</code></pre> In this case, the expected order of axes is <code>('y', 'x', 't')</code> as wavelength is scalar, so all optical elements will expect wavefront tensors with shape <code>(..., Ny, Nx, Nt)</code>.</p>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.names","title":"names  <code>property</code>","text":"<pre><code>names: tuple[str, ...]\n</code></pre> <p>Get names of non-scalar axes (those with length &gt; 1).</p>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.names_scalar","title":"names_scalar  <code>property</code>","text":"<pre><code>names_scalar: tuple[str, ...]\n</code></pre> <p>Get names of scalar (0-dimensional) axes.</p>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.device","title":"device  <code>property</code>","text":"<pre><code>device: device\n</code></pre> <p>Get the device where all axes are stored.</p>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.from_ranges","title":"from_ranges  <code>classmethod</code>","text":"<pre><code>from_ranges(\n    *,\n    x_range: tuple[float, float],\n    x_points: int,\n    y_range: tuple[float, float],\n    y_points: int,\n    wavelength: Tensor | float,\n    **additional_axes: Tensor | float\n) -&gt; Self\n</code></pre> <p>Create SimulationParameters from coordinate ranges.</p> <p>Parameters:</p> <ul> <li> <code>x_range</code>               (<code>tuple[float, float]</code>)           \u2013            <p>(min, max) range for x-axis. Use <code>ureg</code> for units.</p> </li> <li> <code>x_points</code>               (<code>int</code>)           \u2013            <p>Number of points along x-axis.</p> </li> <li> <code>y_range</code>               (<code>tuple[float, float]</code>)           \u2013            <p>(min, max) range for y-axis. Use <code>ureg</code> for units.</p> </li> <li> <code>y_points</code>               (<code>int</code>)           \u2013            <p>Number of points along y-axis.</p> </li> <li> <code>wavelength</code>               (<code>Tensor | float</code>)           \u2013            <p>Optical wavelength. Use <code>ureg</code> for units.</p> </li> <li> <code>**additional_axes</code>               (<code>Tensor | float</code>, default:                   <code>{}</code> )           \u2013            <p>Additional axes.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from svetlanna.units import ureg\n&gt;&gt;&gt; params = SimulationParameters.from_ranges(\n...     x_range=(-1*ureg.mm, 1*ureg.mm), x_points=256,\n...     y_range=(-1*ureg.mm, 1*ureg.mm), y_points=256,\n...     wavelength=632.8*ureg.nm\n... )\n</code></pre>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(axes_dict: Mapping[str, Tensor | float]) -&gt; Self\n</code></pre> <p>Create SimulationParameters from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>axes_dict</code>               (<code>Mapping[str, Tensor | float]</code>)           \u2013            <p>Dictionary with axis names as keys and tensor/scalar values.</p> </li> </ul>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.clone","title":"clone","text":"<pre><code>clone() -&gt; 'SimulationParameters'\n</code></pre> <p>Create a deep copy of the SimulationParameters instance.</p> <p>Returns:</p> <ul> <li> <code>SimulationParameters</code>           \u2013            <p>A new instance with cloned axes.</p> </li> </ul>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.equal","title":"equal","text":"<pre><code>equal(value: SimulationParameters) -&gt; bool\n</code></pre> <p>Check equality with another SimulationParameters instance. The comparison between tensor axes is based on <code>torch.equal</code>, see documentation for more details. Comparing instances on diffrent devices will raise <code>RuntimeError</code> because <code>torch.equal</code> requires tensors to be on the same device.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>SimulationParameters</code>)           \u2013            <p>SimulationParameters instance to compare with.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all axes are equal, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.meshgrid","title":"meshgrid","text":"<pre><code>meshgrid(x_axis: str, y_axis: str) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Create a coordinate meshgrid from two axes.</p> <p>Parameters:</p> <ul> <li> <code>x_axis</code>               (<code>str</code>)           \u2013            <p>Name of the axis for x-coordinates (typically 'x').</p> </li> <li> <code>y_axis</code>               (<code>str</code>)           \u2013            <p>Name of the axis for y-coordinates (typically 'y').</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>x_grid, y_grid : tuple[torch.Tensor, torch.Tensor]</code>           \u2013            <p>2D coordinate grids with 'xy' indexing convention.</p> </li> </ul>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.axes_size","title":"axes_size  <code>cached</code>","text":"<pre><code>axes_size(axs: tuple[str, ...] | None = None) -&gt; Size\n</code></pre> <p>Get the size of specified axes in order (cached for performance).</p> <p>Parameters:</p> <ul> <li> <code>axs</code>               (<code>tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of axis names in the desired order. For legacy compatibility, also accepts axs=(...) keyword argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Size</code>           \u2013            <p>Size object with lengths of specified axes.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; size = params.axes_size(('y', 'x'))  # New API (cached)\n&gt;&gt;&gt; size = params.axes_size(axs=('y', 'x'))  # Legacy API\n</code></pre>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.index","title":"index","text":"<pre><code>index(name: str) -&gt; int\n</code></pre> <p>Get the negative index of an axis in tensors.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the axis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Negative index for use in tensor operations.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AxisNotFound</code>             \u2013            <p>If the axis doesn't exist or is scalar.</p> </li> </ul>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.cast","title":"cast","text":"<pre><code>cast(\n    tensor: Tensor, *axes: str, shape_check: bool = True\n) -&gt; Tensor\n</code></pre> <p>Cast tensor to match simulation parameters axes for broadcasting.</p> <p>Reshapes tensor so it can be broadcast with wavefront tensors. Scalar axes are skipped (they don't affect tensor shape).</p> <p>Parameters:</p> <ul> <li> <code>tensor</code>               (<code>Tensor</code>)           \u2013            <p>Input tensor whose trailing dimensions correspond to <code>axes</code>.</p> </li> <li> <code>*axes</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>Axes names corresponding to tensor's trailing dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Tensor reshaped for broadcasting with wavefront.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # axes: (wavelength, H, W), shapes: (5, 2, 3)\n&gt;&gt;&gt; a = torch.rand(2, 3)  # H, W\n&gt;&gt;&gt; a = sim_params.cast(a, \"H\", \"W\")\n&gt;&gt;&gt; a.shape\ntorch.Size([1, 2, 3])  # ready to broadcast with (5, 2, 3)\n</code></pre>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.reorder","title":"reorder","text":"<pre><code>reorder(tensor: Tensor, *trailing_axes: str) -&gt; Tensor\n</code></pre> <p>Permute tensor so that specified axes are last, in the given order.</p> <p>Parameters:</p> <ul> <li> <code>tensor</code>               (<code>Tensor</code>)           \u2013            <p>Input tensor whose trailing dimensions correspond to axes.names.</p> </li> <li> <code>*trailing_axes</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>Axis names that should become the last dimensions (in order).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Permuted tensor with trailing_axes as the last dimensions.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # axes: (wavelength, H, W), tensor shape: (batch, wavelength, H, W)\n&gt;&gt;&gt; t = sim_params.reorder(tensor, \"H\", \"W\")      # no change\n&gt;&gt;&gt; t = sim_params.reorder(tensor, \"W\", \"H\")      # -&gt; (batch, wavelength, W, H)\n&gt;&gt;&gt; t = sim_params.reorder(tensor, \"wavelength\")  # -&gt; (batch, H, W, wavelength)\n</code></pre>"},{"location":"reference/simulation_parameters/#svetlanna.SimulationParameters.to","title":"to","text":"<pre><code>to(device: str | device | int) -&gt; Self\n</code></pre> <p>Move all axes to a different device (inplace).</p> <p>Unlike tensor.to() which returns a new tensor, this method mutates the instance inplace (like nn.Module.to()) to ensure all Elements sharing this SimulationParameters stay in sync.</p> <p>Parameters:</p> <ul> <li> <code>device</code>               (<code>str | device | int</code>)           \u2013            <p>Target device.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The same instance (for chaining).</p> </li> </ul>"},{"location":"reference/units/","title":"Units","text":""},{"location":"reference/units/#svetlanna.units.ureg","title":"svetlanna.units.ureg","text":"<p>               Bases: <code>Enum</code></p> <p>Unit registry for SI-prefixed length, time, and frequency units.</p> <p>A simple unit registry supporting SI prefixes (T, G, M, k, m, u, n, p, f, a) for length (m), time (s), and frequency (Hz) units. Supports basic arithmetic operations with scalars.</p> Warning <p>Units are multiplicative factors only; they carry no information about the physical quantity. Keep eye on the units you use to ensure consistency across calculations.</p> Warning <p>Round-off errors may occur when using very large and very small units due to floating-point precision limits.</p> <p>Examples:</p> <pre><code>from svetlanna.units import ureg\n\nwavelength = 500 * ureg.nm  # 5e-7\nx = torch.linspace(-5 * ureg.mm, 5 * ureg.mm, 10)\ny = torch.linspace(-5, 5, 10) * ureg.mm\n\nprint(f'\u03bb={wavelength / ureg.um:.3f} \u03bcm')  # &gt;&gt;&gt; \u03bb=0.500 \u03bcm\n</code></pre> <p>Attributes:</p> <ul> <li> <code>Gm, Mm, km, m, dm, cm, mm, um, nm, pm</code>               (<code>float</code>)           \u2013            <p>Length units (gigameters to picometers).</p> </li> <li> <code>Gs, Ms, ks, s, ds, cs, ms, us, ns, ps, fs, as_</code>               (<code>float</code>)           \u2013            <p>Time units (gigaseconds to attoseconds).</p> </li> <li> <code>THz, GHz, MHz, kHz, Hz, dHz, cHz, mHz, uHz, nHz, pHz</code>               (<code>float</code>)           \u2013            <p>Frequency units (terahertz to picohertz).</p> </li> </ul>"},{"location":"reference/visualization/","title":"Visualization","text":""},{"location":"reference/visualization/#svetlanna.visualization.show_structure","title":"svetlanna.visualization.show_structure","text":"<pre><code>show_structure(*specsable: Specsable)\n</code></pre> <p>Display a setup structure using IPython's HTML display. Useful for previewing specs hierarchies in notebooks.</p> <p>Parameters:</p> <ul> <li> <code>*specsable</code>               (<code>Specsable</code>, default:                   <code>()</code> )           \u2013            <p>One or more specsable elements to display</p> </li> </ul> <p>Examples:</p> <p><pre><code>import svetlanna as sv\nimport torch\nfrom svetlanna.visualization import show_structure\n\nNx = Ny = 128\nsim_params = sv.SimulationParameters(\n    x=torch.linspace(-1, 1, Nx),\n    y=torch.linspace(-1, 1, Ny),\n    wavelength=0.1,\n)\n\nsetup = sv.LinearOpticalSetup(\n    [\n        sv.elements.RectangularAperture(sim_params, width=0.5, height=0.5),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n        sv.elements.DiffractiveLayer(sim_params, mask=torch.rand(Ny, Nx), mask_norm=1),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n    ]\n)\n\nshow_structure(setup)\n</code></pre> Output (in IPython environment):</p> <p> </p>"},{"location":"reference/visualization/#svetlanna.visualization.show_specs","title":"svetlanna.visualization.show_specs","text":"<pre><code>show_specs(*specsable: Specsable) -&gt; SpecsWidget\n</code></pre> <p>Display a setup structure with interactive specs preview</p> <p>Returns:</p> <ul> <li> <code>SpecsWidget</code>           \u2013            <p>The widget</p> </li> </ul> <p>Examples:</p> <p><pre><code>import svetlanna as sv\nimport torch\nfrom svetlanna.visualization import show_specs\n\nNx = Ny = 128\nsim_params = sv.SimulationParameters(\n    x=torch.linspace(-1, 1, Nx),\n    y=torch.linspace(-1, 1, Ny),\n    wavelength=0.1,\n)\n\nsetup = sv.LinearOpticalSetup(\n    [\n        sv.elements.RectangularAperture(sim_params, width=0.5, height=0.5),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n        sv.elements.DiffractiveLayer(sim_params, mask=torch.rand(Ny, Nx), mask_norm=1),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n    ]\n)\n\nshow_specs(setup)\n</code></pre> Output (in IPython environment):</p> <p> </p>"},{"location":"reference/visualization/#svetlanna.visualization.show_stepwise_forward","title":"svetlanna.visualization.show_stepwise_forward","text":"<pre><code>show_stepwise_forward(\n    *specsable: Specsable,\n    input: Tensor,\n    simulation_parameters: SimulationParameters,\n    types_to_plot: tuple[StepwisePlotTypes, ...] = (\n        \"I\",\n        \"phase\",\n    )\n) -&gt; StepwiseForwardWidget\n</code></pre> <p>Display the wavefront propagation through a setup structure using a widget interface. Currently only wavefronts of shape <code>(x, y)</code> are supported.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>Tensor</code>)           \u2013            <p>The Input wavefront</p> </li> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters</p> </li> <li> <code>types_to_plot</code>               (<code>tuple[StepwisePlotTypes, ...]</code>, default:                   <code>('I', 'phase')</code> )           \u2013            <p>Field properties to plot, by default ('I', 'phase')</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StepwiseForwardWidget</code>           \u2013            <p>The widget</p> </li> </ul> <p>Examples:</p> <p><pre><code>import svetlanna as sv\nimport torch\nfrom svetlanna.visualization import show_stepwise_forward\n\nNx = Ny = 128\nsim_params = sv.SimulationParameters(\n    x=torch.linspace(-1, 1, Nx),\n    y=torch.linspace(-1, 1, Ny),\n    wavelength=0.1,\n)\n\nsetup = sv.LinearOpticalSetup(\n    [\n        sv.elements.RectangularAperture(sim_params, width=0.5, height=0.5),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n        sv.elements.DiffractiveLayer(sim_params, mask=torch.rand(Ny, Nx), mask_norm=1),\n        sv.elements.FreeSpace(sim_params, distance=0.2, method=\"AS\"),\n    ]\n)\n\ninput_wavefront = sv.Wavefront.plane_wave(sim_params)\nshow_stepwise_forward(\n    setup,\n    input=input_wavefront,\n    simulation_parameters=sim_params,\n    types_to_plot=(\"I\", \"phase\", \"Re\"),\n)\n</code></pre> Output (in IPython environment):</p> <p> </p>"},{"location":"reference/wavefront/","title":"Wavefront","text":""},{"location":"reference/wavefront/#svetlanna.Wavefront","title":"svetlanna.Wavefront","text":"<p>               Bases: <code>Tensor</code></p> <p>Class that represents wavefront. It is a subclass of <code>torch.Tensor</code> with additional properties and methods for wavefront analysis and generation.</p>"},{"location":"reference/wavefront/#svetlanna.Wavefront.intensity","title":"intensity  <code>property</code>","text":"<pre><code>intensity: Tensor\n</code></pre> <p>Intensity of the wavefront.</p> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Intensity (\\(|E|^2\\)).</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.max_intensity","title":"max_intensity  <code>property</code>","text":"<pre><code>max_intensity: float\n</code></pre> <p>Maximum intensity of the wavefront.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Maximum intensity value.</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.phase","title":"phase  <code>property</code>","text":"<pre><code>phase: Tensor\n</code></pre> <p>Phase of the wavefront.</p> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Phase angle in the range \\([-\\pi, \\pi]\\).</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.fwhm","title":"fwhm","text":"<pre><code>fwhm(\n    simulation_parameters: SimulationParameters,\n) -&gt; tuple[float, float]\n</code></pre> <p>Full width at half maximum (FWHM) of the wavefront intensity.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>FWHM along x and y axes.</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.plane_wave","title":"plane_wave  <code>classmethod</code>","text":"<pre><code>plane_wave(\n    simulation_parameters: SimulationParameters,\n    distance: float = 0.0,\n    wave_direction: Any = None,\n    initial_phase: float = 0.0,\n) -&gt; Self\n</code></pre> <p>Create a plane wave wavefront defind by the formula $$ E(x, y) = \\exp\\left( i \\left( k_x x + k_y y + k_z z + \\phi_0 \\right) \\right) $$</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Free wave propagation distance \\(z\\), by default 0.</p> </li> <li> <code>wave_direction</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Three component tensor-like vector with (\\(d_x\\), \\(d_y\\), \\(d_z\\)) coordinates, so \\(\\vec{k} = k \\frac{\\vec{d}}{||\\vec{d}||}\\) The resulting field propagates along the vector, by default the wave propagates along z direction.</p> </li> <li> <code>initial_phase</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Additional phase offset (\\(\\phi_0\\)), by default 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Wavefront</code>           \u2013            <p>Plane wave field.</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.gaussian_beam","title":"gaussian_beam  <code>classmethod</code>","text":"<pre><code>gaussian_beam(\n    simulation_parameters: SimulationParameters,\n    waist_radius: float,\n    distance: float = 0.0,\n    dx: float = 0.0,\n    dy: float = 0.0,\n) -&gt; Self\n</code></pre> <p>Generates the Gaussian beam wavefront defined by the formula $$ E(x, y) = \\frac{w_0}{w(z)} \\exp\\left( -\\frac{(x - d_x)^2 + (y - d_y)^2}{w(z)^2} \\right) \\exp\\left( i \\left( k z + k\\frac{(x - d_x)^2 + (y - d_y)^2}{2 R(z)} - \\zeta(z) \\right) \\right) $$ where \\(w(z) = w_0 \\sqrt{1 + \\left( \\frac{z}{z_R} \\right)^2}\\), \\(R(z) = z \\left( 1 + \\left( \\frac{z_R}{z} \\right)^2 \\right)\\), \\(\\zeta(z) = \\arctan\\left( \\frac{z}{z_R} \\right)\\), and \\(z_R = \\frac{\\pi w_0^2}{\\lambda}\\) is the Rayleigh range.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>waist_radius</code>               (<code>float</code>)           \u2013            <p>Beam waist radius (\\(w_0\\)).</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Free wave propagation distance \\(z\\), by default 0.</p> </li> <li> <code>dx</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Horizontal offset of the beam center (\\(d_x\\)), by default 0.</p> </li> <li> <code>dy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Vertical offset of the beam center (\\(d_y\\)), by default 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Wavefront</code>           \u2013            <p>Gaussian beam field in the oXY plane.</p> </li> </ul>"},{"location":"reference/wavefront/#svetlanna.Wavefront.spherical_wave","title":"spherical_wave  <code>classmethod</code>","text":"<pre><code>spherical_wave(\n    simulation_parameters: SimulationParameters,\n    distance: float,\n    initial_phase: float = 0.0,\n    dx: float = 0.0,\n    dy: float = 0.0,\n) -&gt; Self\n</code></pre> <p>Generate wavefront of the spherical wave $$ E(x, y) = \\frac{1}{r} \\exp\\left( i \\left( k r + \\phi_0 \\right) \\right) $$ where \\(r = \\sqrt{(x - d_x)^2 + (y - d_y)^2 + z^2}\\) is the distance from the point source to the point \\((x, y)\\) in the oXY plane.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>distance</code>               (<code>float</code>)           \u2013            <p>Distance from the point source to the oXY plane (\\(z\\)).</p> </li> <li> <code>initial_phase</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Phase offset at the source (\\(\\phi_0\\)), by default 0.</p> </li> <li> <code>dx</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Horizontal position of the point source (\\(d_x\\)), by default 0.</p> </li> <li> <code>dy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Vertical position of the point source (\\(d_y\\)), by default 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Wavefront</code>           \u2013            <p>Spherical wave field in the oXY plane.</p> </li> </ul>"},{"location":"reference/elements/apertures/","title":"Apertures","text":""},{"location":"reference/elements/apertures/#svetlanna.elements.aperture.AbstractMulElement","title":"svetlanna.elements.aperture.AbstractMulElement","text":"<pre><code>AbstractMulElement(\n    simulation_parameters: SimulationParameters,\n)\n</code></pre> <p>               Bases: <code>Element</code>, <code>ABC</code></p> <p>Class that generalize all apertures with \\(E^\\text{out} = \\hat{T}E^\\text{in}\\) like forward function, where \\(\\hat{T}\\) is transmission function.</p>"},{"location":"reference/elements/apertures/#svetlanna.elements.aperture.AbstractMulElement.transmission_function","title":"transmission_function  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>transmission_function: Tensor\n</code></pre> <p>The tensor representing transmission function of the element, \\(\\hat{T}\\). The shape of the transmission function should be broadcastable to the shape of the incident wavefront. To achive this, one can use <code>SimpulationParameters.cast</code> method to cast the transmission function to the shape of the incident wavefront: <pre><code>@property\ndef transmission_function(self) -&gt; torch.Tensor:\n    T = ...  # tensor with shape (Ny, Nx)\n    return self.simulation_parameters.cast(T, \"y\", \"x\")\n</code></pre></p>"},{"location":"reference/elements/apertures/#svetlanna.elements.Aperture","title":"svetlanna.elements.Aperture","text":"<pre><code>Aperture(\n    simulation_parameters: SimulationParameters,\n    mask: OptimizableTensor,\n)\n</code></pre> <p>               Bases: <code>AbstractMulElement</code></p> <p>Aperture defined by mask tensor. Commonly, the mask is a tensor with values of either 0 or 1, where 0 represents blocked light and 1 represents allowed light.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>mask</code>               (<code>Tensor</code>)           \u2013            <p>Two-dimensional tensor representing the aperture mask of shape <code>(Ny, Nx)</code>. The mask works as following:</p> \\[E^\\text{out}_{xyw...} = \\text{mask}_{xy} E^\\text{in}_{xyw...}\\] <p>In this case 0 blocks light and 1 allows light go through.</p> </li> </ul>"},{"location":"reference/elements/apertures/#svetlanna.elements.RectangularAperture","title":"svetlanna.elements.RectangularAperture","text":"<pre><code>RectangularAperture(\n    simulation_parameters: SimulationParameters,\n    height: float,\n    width: float,\n)\n</code></pre> <p>               Bases: <code>AbstractMulElement</code></p> <p>Rectangular aperture. Through the rectangular area of defined height and width located in the center the light is allowed to pass, otherwise blocked.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Aperture height.</p> </li> <li> <code>width</code>               (<code>float</code>)           \u2013            <p>Aperture width.</p> </li> </ul>"},{"location":"reference/elements/apertures/#svetlanna.elements.RoundAperture","title":"svetlanna.elements.RoundAperture","text":"<pre><code>RoundAperture(\n    simulation_parameters: SimulationParameters,\n    radius: float,\n)\n</code></pre> <p>               Bases: <code>AbstractMulElement</code></p> <p>Round-shaped aperture. Through the round area of defined radius located in the center the light is allowed to pass, otherwise blocked.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>radius</code>               (<code>float</code>)           \u2013            <p>Radius of the round-shaped aperture.</p> </li> </ul>"},{"location":"reference/elements/diffractive_layers/","title":"Diffractive Layers","text":""},{"location":"reference/elements/diffractive_layers/#svetlanna.elements.DiffractiveLayer","title":"svetlanna.elements.DiffractiveLayer","text":"<pre><code>DiffractiveLayer(\n    simulation_parameters: SimulationParameters,\n    mask: OptimizableTensor,\n    mask_norm: float = 2 * pi,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Diffractive layer defined by a phase mask. The field after propagating through the layer is calculated as:</p> \\[ E^\\text{out}_{xyw...} = E^\\text{in}_{xyw...} \\cdot \\exp\\left(2\\pi i \\frac{\\text{mask}_{xy}}{\\text{mask\\_norm}}\\right) \\] <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>mask</code>               (<code>OptimizableTensor</code>)           \u2013            <p>Two-dimensional tensor representing the aperture mask of shape <code>(H, W)</code>.</p> </li> <li> <code>mask_norm</code>               (<code>float</code>, default:                   <code>2 * pi</code> )           \u2013            <p>Mask normalization factor.</p> </li> </ul>"},{"location":"reference/elements/diffractive_layers/#svetlanna.elements.DiffractiveLayer.transmission_function","title":"transmission_function  <code>property</code>","text":"<pre><code>transmission_function: Tensor\n</code></pre> <p>The tensor representing the transmission function of the element \\(\\exp\\left(2\\pi i \\dfrac{\\text{mask}}{\\text{mask\\_norm}}\\right)\\). The shape of the tensor is broadcastable to the incident wavefront's shape.</p>"},{"location":"reference/elements/element/","title":"Element","text":""},{"location":"reference/elements/element/#svetlanna.elements.Element","title":"svetlanna.elements.Element","text":"<pre><code>Element(simulation_parameters: SimulationParameters)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>This is the abstract class for all optical elements in SVETlANNa. It is inherited from <code>torch.nn.Module</code>, so it is PyTorch-compatible. Each element takes an incident wavefront and produces a transmitted wavefront.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> </ul>"},{"location":"reference/elements/element/#svetlanna.elements.Element.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(incident_wavefront: Wavefront) -&gt; Wavefront\n</code></pre> <p>Forward propagation through the optical element.</p>"},{"location":"reference/elements/element/#svetlanna.elements.Element.to","title":"to","text":"<pre><code>to(*args, **kwargs) -&gt; Self\n</code></pre> <p>Move element to a different device/dtype.</p> <p>Overrides <code>torch.nn.Module.to()</code> to also transfer simulation_parameters.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The element itself, not a copy.</p> </li> </ul>"},{"location":"reference/elements/element/#svetlanna.elements.Element.make_buffer","title":"make_buffer","text":"<pre><code>make_buffer(\n    name: str, value: _T, persistent: bool = False\n) -&gt; _T\n</code></pre> <p>Make buffer for internal use.</p> <p>Use case in <code>__init__</code> method: <pre><code>self.mask = self.make_buffer('mask', some_tensor)\n</code></pre> This allow torch to properly process the <code>.to</code> method on the element, since the buffer <code>maask</code> will be transferred to the required device along with simulation parameters. This allows torch to properly process the <code>.to</code> method on the element, since the buffer <code>mask</code> will be transferred to the required device along with simulation parameters.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the new buffer (it is more convenient to use the name of the new attribute).</p> </li> <li> <code>value</code>               (<code>_T</code>)           \u2013            <p>Tensor to be buffered.</p> </li> <li> <code>persistent</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>See torch docs on buffers, by default <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The value passed to the method.</p> </li> </ul>"},{"location":"reference/elements/element/#svetlanna.elements.Element.process_parameter","title":"process_parameter","text":"<pre><code>process_parameter(name: str, value: _V) -&gt; _V\n</code></pre> <p>Process element parameter passed by user. Automatically registers buffer for non-parametric tensors.</p> <p>Use case in <code>__init__</code> method: <pre><code>class SomeElement(Element):\n    def __init__(self, simulation_parameters, mask, a):\n        super().__init__(simulation_parameters)\n\n        self.mask = self.process_parameter('mask', mask)\n        self.a = self.process_parameter('a', a)\n\n        ...\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the new buffer (it is more convenient to use the name of the new attribute).</p> </li> <li> <code>value</code>               (<code>_V</code>)           \u2013            <p>The value of the element parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_V</code>           \u2013            <p>The value passed to the method.</p> </li> </ul>"},{"location":"reference/elements/nonlinear_elements/","title":"Nonlinear Elements","text":""},{"location":"reference/elements/nonlinear_elements/#svetlanna.elements.NonlinearElement","title":"svetlanna.elements.NonlinearElement","text":"<pre><code>NonlinearElement(\n    simulation_parameters: SimulationParameters,\n    response_function: Callable[[Wavefront], Wavefront],\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Nonlinear optical element with a given response function. The response function takes an incident wavefront and returns the modified wavefront.</p> <p>Examples:</p> <p>Suppose the response function is defined as \\(E^\\text{out} = \\sqrt{|E^\\text{in}|}e^{i \\arg(E^\\text{in})}\\): <pre><code>import svetlanna as sv\nimport torch\n\nsim_params = sv.SimulationParameters(...)\n\nsv.elements.NonlinearElement(\n    simulation_parameters=sim_params,\n    response_function = lambda E: torch.polar(torch.sqrt(E.abs()), E.angle())\n)\n</code></pre></p> <p>If you want to optimize the parameters of the response function, you can use <code>svetlanna.PartialWithParameters</code> to wrap the response function with trainable parameters. For example, if the response function is defined as \\(E^\\text{out} = |E^\\text{in}|^a e^{i b \\arg(E^\\text{in})}\\), where \\(0&lt;a&lt;1\\) and \\(b\\) are trainable, you can define the nonlinear element as follows: <pre><code>def response_function(E, a, b):\n    return torch.polar(E.abs()**a, b * E.angle())\n\nsv.elements.NonlinearElement(\n    simulation_parameters=sim_params,\n    response_function = sv.PartialWithParameters(\n        response_function,\n        a=sv.ConstrainedParameter(0.5, min_value=0.0, max_value=1.0),\n        b=sv.Parameter(1.0),\n    ),\n)\n</code></pre></p> <p>You can also train a neural network inside the nonlinear element! <pre><code>sv.elements.NonlinearElement(\n    simulation_parameters=sim_params,\n    response_function=my_neural_network,\n)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>response_function</code>               (<code>Callable[[Wavefront], Wavefront]</code>)           \u2013            <p>Function that describes the nonlinear response of the element.</p> </li> </ul>"},{"location":"reference/elements/slm/","title":"SpatialLightModulator","text":""},{"location":"reference/elements/slm/#svetlanna.elements.SpatialLightModulator","title":"svetlanna.elements.SpatialLightModulator","text":"<pre><code>SpatialLightModulator(\n    simulation_parameters: SimulationParameters,\n    mask: OptimizableTensor,\n    height: float,\n    width: float,\n    lut_function: _F = identity,\n    center: Tuple[float, float] = (0.0, 0.0),\n    mode: Literal[\n        \"nearest\",\n        \"bilinear\",\n        \"bicubic\",\n        \"area\",\n        \"nearest-exact\",\n    ] = \"nearest\",\n)\n</code></pre> <p>               Bases: <code>Element</code>, <code>Generic[_F]</code></p> <p>Spatial Light Modulator (SLM) element implementation. SLM supports pixel size that differs from the simulation grid size. The lookup table function (<code>lut_function</code>) allows applying a non-linear transformation to the mask values, for example, to implement quantization.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>mask</code>               (<code>OptimizableTensor</code>)           \u2013            <p>Mask tensor of the shape <code>(Ny_mask, Nx_mask)</code>, where <code>Ny_mask</code> and <code>Nx_mask</code> are the height and width of the mask in pixels. It can be different from the simulation grid shape <code>(Ny, Nx)</code>; interpolation is applied to fit the mask to the SLM area.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height of the SLM.</p> </li> <li> <code>width</code>               (<code>float</code>)           \u2013            <p>Width of the SLM.</p> </li> <li> <code>lut_function</code>               (<code>_F</code>, default:                   <code>identity</code> )           \u2013            <p>Lookup table function applied to the mask values, by default <code>identity</code>.</p> </li> <li> <code>center</code>               (<code>Tuple[float, float]</code>, default:                   <code>(0.0, 0.0)</code> )           \u2013            <p>Center coordinate <code>(x, y)</code> of the SLM in the simulation grid coordinates, by default <code>(0.0, 0.0)</code>.</p> </li> <li> <code>mode</code>               (<code>Literal['nearest', 'bilinear', 'bicubic', 'area', 'nearest-exact']</code>, default:                   <code>'nearest'</code> )           \u2013            <p>Interpolation mode for resizing the mask, by default <code>'nearest'</code>. See <code>torch.nn.functional.interpolate</code> documentation for more details.</p> </li> </ul>"},{"location":"reference/elements/slm/#svetlanna.elements.slm.QuantizerFromStepFunction","title":"svetlanna.elements.slm.QuantizerFromStepFunction","text":"<pre><code>QuantizerFromStepFunction(\n    N: int,\n    max_value: float,\n    one_step_function: Callable[\n        Concatenate[Tensor, Params], Tensor\n    ],\n) -&gt; Callable[Concatenate[Tensor, Params], Tensor]\n</code></pre> <p>Create a quantizer function from a given one-step function. The resulting quantizer function takes a tensor of values from 0 to <code>max_value</code> and returns a tensor of values from 0 to <code>max_value</code> with <code>N</code> quantization levels. Each level is defined as the output of the one-step function at the fractional part of the input value, divided by <code>max_value</code> and multiplied by <code>N</code>.</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>Number of quantization levels.</p> </li> <li> <code>max_value</code>               (<code>float</code>)           \u2013            <p>Maximum value of the input tensor.</p> </li> <li> <code>one_step_function</code>               (<code>Callable[Concatenate[Tensor, Params], Tensor]</code>)           \u2013            <p>The one-step function that takes a tensor of values from 0 to 1 as the first argument and returns a tensor of values from 0 to 1. The function should have a steep transition from 0 to 1, and the steepness can be controlled by an additional parameter (for example, alpha). The function should satisfy the following conditions: \\(f(0) = 0\\), \\(f(1)=1\\), and \\(f'(0) = f'(1)\\) to ensure that the quantizer function is continuous and smooth.</p> </li> </ul> <p>Examples:</p> <pre><code>import svetlanna as sv\nfrom svetlanna.elements.slm import QuantizerFromStepFunction, one_step_tanh\n\nsv.elements.SpatialLightModulator(\n    lut_function=sv.PartialWithParameters(\n        QuantizerFromStepFunction(\n            N=256,\n            max_value=2 * torch.pi,\n            one_step_function=one_step_tanh\n        ),\n        alpha=torch.tensor(1.0),\n    ),\n    ...\n)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Callable[Concatenate[Tensor, Params], Tensor]</code>           \u2013            <p>Quantizer function that takes the same parameters as the one-step function and applies quantization to the input tensor.</p> </li> </ul>"},{"location":"reference/elements/slm/#svetlanna.elements.slm.one_step_tanh","title":"svetlanna.elements.slm.one_step_tanh","text":"<pre><code>one_step_tanh(x: Tensor, alpha: Tensor) -&gt; Tensor\n</code></pre> <p>A one-step function that can be used in QuantizerFromStepFunction. This function is defined as</p> \\[f(x) = \\dfrac{\\tanh(\\alpha(x-0.5))}{2\\tanh(\\alpha/2)} + \\frac{1}{2}\\] <p>The parameter \\(\\alpha \\in [0, +\\infty)\\) controls the steepness of the transition. \\(\\alpha=0\\) corresponds to a linear function.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Tensor</code>)           \u2013            <p>Input tensor with values from 0 to 1.</p> </li> <li> <code>alpha</code>               (<code>Tensor</code>)           \u2013            <p>Steepness control parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Output tensor with values from 0 to 1.</p> </li> </ul>"},{"location":"reference/elements/slm/#svetlanna.elements.slm.one_step_cos","title":"svetlanna.elements.slm.one_step_cos","text":"<pre><code>one_step_cos(x: Tensor, alpha: Tensor) -&gt; Tensor\n</code></pre> <p>A one-step function that can be used in QuantizerFromStepFunction. This function is defined as</p> \\[f(x) = \\dfrac{1 - \\cos(\\pi x^{\\alpha + 1})}{2}\\] <p>The parameter \\(\\alpha \\in [0, +\\infty)\\) controls the steepness of the transition. \\(\\alpha=0\\) corresponds to a function with a smooth transition, but not linear, and as \\(\\alpha\\) increases, the transition becomes steeper.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Tensor</code>)           \u2013            <p>Input tensor with values from 0 to 1.</p> </li> <li> <code>alpha</code>               (<code>Tensor</code>)           \u2013            <p>Steepness control parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>           \u2013            <p>Output tensor with values from 0 to 1.</p> </li> </ul>"},{"location":"reference/elements/thin_lens/","title":"Thin Lens","text":""},{"location":"reference/elements/thin_lens/#svetlanna.elements.ThinLens","title":"svetlanna.elements.ThinLens","text":"<pre><code>ThinLens(\n    simulation_parameters: SimulationParameters,\n    focal_length: OptimizableFloat,\n    radius: float = inf,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Thin lens element.</p> <p>Parameters:</p> <ul> <li> <code>simulation_parameters</code>               (<code>SimulationParameters</code>)           \u2013            <p>Simulation parameters.</p> </li> <li> <code>focal_length</code>               (<code>OptimizableFloat</code>)           \u2013            <p>The focal length of the lens. \\(\\text{focal\\_length} &gt; 0\\) for a converging lens.</p> </li> <li> <code>radius</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            <p>The radius of the thin lens. The field outside the radius (\\(x^2 + y^2 &gt; \\text{radius}^2\\)) will propagate with no change in phase. Default is infinity, meaning that the lens has no aperture and the field will propagate with a phase change everywhere.</p> </li> </ul>"},{"location":"reference/elements/thin_lens/#svetlanna.elements.ThinLens.transmission_function","title":"transmission_function  <code>property</code>","text":"<pre><code>transmission_function: Tensor\n</code></pre> <p>The tensor representing the transmission function of the element \\(\\exp\\left(-i \\dfrac{k}{2f} (x^2 + y^2)\\right)\\), where \\(k\\) is the wave number and \\(f\\) is the focal length. The radius of the lens is taken into account. The shape of the tensor is broadcastable to the incident wavefront's shape.</p>"}]}